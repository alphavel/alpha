<?php

namespace Alphavel\Alpha\Console\Commands;

use Alphavel\Alpha\Console\Command;

class RouteCacheCommand extends Command
{
    protected string $signature = 'route:cache';
    protected string $description = 'Create a route cache file for faster route registration';

    public function handle(): int
    {
        $this->info('Caching routes...');

        // Load routes to memory
        $cwd = getcwd();
        $routesFile = $cwd . '/routes/api.php';
        
        if (!file_exists($routesFile)) {
            $this->error('Routes file not found: routes/api.php');
            return self::FAILURE;
        }

        // Create minimal router instance to capture routes
        require $cwd . '/vendor/autoload.php';
        
        $routerClass = '\\Alphavel\\Framework\\Router';
        if (!class_exists($routerClass)) {
            $this->error('Router class not found. Is alphavel/alphavel installed?');
            return self::FAILURE;
        }

        $router = new $routerClass();
        
        // Load routes
        require $routesFile;
        
        // Get route definitions
        $staticRoutes = $router->getStaticRoutes();
        $dynamicRoutes = $router->getDynamicRoutes();
        $rawRoutes = $router->getRawRoutes();

        // Serialize routes to PHP array
        $cacheData = [
            'static' => $this->serializeRoutes($staticRoutes),
            'dynamic' => $this->serializeRoutes($dynamicRoutes),
            'raw' => $rawRoutes, // Raw routes are already simple arrays
        ];

        // Write cache file
        $cacheDir = $cwd . '/bootstrap/cache';
        $cacheFile = $cacheDir . '/routes.php';
        
        if (!is_dir($cacheDir)) {
            mkdir($cacheDir, 0755, true);
        }

        $content = "<?php\n\n// This file is automatically generated. Do not edit.\n";
        $content .= "// Generated at: " . date('Y-m-d H:i:s') . "\n\n";
        $content .= "return " . var_export($cacheData, true) . ";\n";

        file_put_contents($cacheFile, $content);

        $staticCount = $this->countRoutes($staticRoutes);
        $dynamicCount = $this->countRoutes($dynamicRoutes);
        $rawCount = $this->countRoutes($rawRoutes);
        $totalCount = $staticCount + $dynamicCount + $rawCount;

        $this->success("Routes cached successfully!");
        $this->info("  Raw routes (zero overhead): {$rawCount}");
        $this->info("  Static routes: {$staticCount}");
        $this->info("  Dynamic routes: {$dynamicCount}");
        $this->info("  Total: {$totalCount}");
        $this->comment("\nâš¡ Route lookup is now optimized for production!");

        return self::SUCCESS;
    }

    private function serializeRoutes(array $routes): array
    {
        $serialized = [];

        foreach ($routes as $method => $methodRoutes) {
            if (!is_array($methodRoutes)) {
                continue;
            }

            foreach ($methodRoutes as $path => $route) {
                if (is_object($route)) {
                    // Route object - extract data
                    $match = $route->matches($path, $method);
                    if ($match) {
                        $serialized[$method][$path] = $match;
                    }
                } elseif (is_array($route)) {
                    // Already serialized
                    $serialized[$method][$path] = $route;
                }
            }
        }

        return $serialized;
    }

    private function countRoutes(array $routes): int
    {
        $count = 0;
        foreach ($routes as $methodRoutes) {
            if (is_array($methodRoutes)) {
                $count += count($methodRoutes);
            }
        }
        return $count;
    }
}
